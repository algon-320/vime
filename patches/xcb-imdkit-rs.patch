diff --git a/Cargo.toml b/Cargo.toml
index 5362c4f..abdf49b 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -19,7 +19,7 @@ name = "example"
 path = "examples/example.rs"
 
 [dependencies]
-xcb = {version="1.1", features=["xkb"], git="https://github.com/wez/rust-xcb", branch="ffi"}
+xcb = { version = "1.2", features=["xkb"] }
 lazy_static = "1.4.0"
 bitflags = "1.3"
 
diff --git a/bindgen.sh b/bindgen.sh
index 9d0c00d..8b82da8 100755
--- a/bindgen.sh
+++ b/bindgen.sh
@@ -1,10 +1,10 @@
 #!/usr/bin/env sh
 
-WHITELIST='(xcb|XCB)_(xim|XIM|im|xic)_.*|xcb_compound_text.*|xcb_utf8_to_compound_text|free'
+WHITELIST='(xcb|XCB)_(xim|XIM|im|xic)_.*|xcb_compound_text.*|xcb_utf8_to_compound_text|free|XCB_IM_ALL_LOCALES'
 
 bindgen \
 	--allowlist-function "$WHITELIST" \
-	--allowlist-type "_xcb_im_style_t" \
+	--allowlist-type "$WHITELIST|_xcb_im_style_t" \
 	--allowlist-var "$WHITELIST" \
 	--size_t-is-usize \
 	--no-layout-tests \
diff --git a/build.rs b/build.rs
index 8fe30f6..a386c0b 100644
--- a/build.rs
+++ b/build.rs
@@ -3,7 +3,7 @@ use std::env;
 const XCB_IMDKIT_SRC: &[&str] = &[
     "parser.c",
     "ximproto.c",
-    // "imdkit.c", // currently unused as this crate only implements the client
+    "imdkit.c",
     "protocolhandler.c",
     "message.c",
     "common.c",
diff --git a/src/bindings.rs b/src/bindings.rs
index 7870365..a856927 100644
--- a/src/bindings.rs
+++ b/src/bindings.rs
@@ -1,4 +1,4 @@
-/* automatically generated by rust-bindgen 0.59.1 */
+/* automatically generated by rust-bindgen 0.61.0 */
 
 pub const XCB_XIM_CM_DATA_SIZE: u32 = 20;
 pub const XCB_XIM_PROTOCOLMAJORVERSION: u32 = 0;
@@ -61,28 +61,25 @@ pub const XCB_XIM_EXTENSION: u32 = 128;
 pub const XCB_XIM_EXT_SET_EVENT_MASK: u32 = 48;
 pub const XCB_XIM_EXT_FORWARD_KEYEVENT: u32 = 50;
 pub const XCB_XIM_EXT_MOVE: u32 = 51;
-pub const XCB_XIM_XNQueryInputStyle: &'static [u8; 16usize] = b"queryInputStyle\0";
-pub const XCB_XIM_XNClientWindow: &'static [u8; 13usize] = b"clientWindow\0";
-pub const XCB_XIM_XNInputStyle: &'static [u8; 11usize] = b"inputStyle\0";
-pub const XCB_XIM_XNFocusWindow: &'static [u8; 12usize] = b"focusWindow\0";
-pub const XCB_XIM_XNFilterEvents: &'static [u8; 13usize] = b"filterEvents\0";
-pub const XCB_XIM_XNPreeditAttributes: &'static [u8; 18usize] = b"preeditAttributes\0";
-pub const XCB_XIM_XNStatusAttributes: &'static [u8; 17usize] = b"statusAttributes\0";
-pub const XCB_XIM_XNArea: &'static [u8; 5usize] = b"area\0";
-pub const XCB_XIM_XNAreaNeeded: &'static [u8; 11usize] = b"areaNeeded\0";
-pub const XCB_XIM_XNSpotLocation: &'static [u8; 13usize] = b"spotLocation\0";
-pub const XCB_XIM_XNColormap: &'static [u8; 9usize] = b"colorMap\0";
-pub const XCB_XIM_XNStdColormap: &'static [u8; 12usize] = b"stdColorMap\0";
-pub const XCB_XIM_XNForeground: &'static [u8; 11usize] = b"foreground\0";
-pub const XCB_XIM_XNBackground: &'static [u8; 11usize] = b"background\0";
-pub const XCB_XIM_XNBackgroundPixmap: &'static [u8; 17usize] = b"backgroundPixmap\0";
-pub const XCB_XIM_XNFontSet: &'static [u8; 8usize] = b"fontSet\0";
-pub const XCB_XIM_XNLineSpace: &'static [u8; 10usize] = b"lineSpace\0";
-pub const XCB_XIM_XNSeparatorofNestedList: &'static [u8; 22usize] = b"separatorofNestedList\0";
-pub type __uint8_t = ::std::os::raw::c_uchar;
-pub type __int16_t = ::std::os::raw::c_short;
-pub type __uint16_t = ::std::os::raw::c_ushort;
-pub type __uint32_t = ::std::os::raw::c_uint;
+pub const XCB_XIM_XNQueryInputStyle: &[u8; 16usize] = b"queryInputStyle\0";
+pub const XCB_XIM_XNClientWindow: &[u8; 13usize] = b"clientWindow\0";
+pub const XCB_XIM_XNInputStyle: &[u8; 11usize] = b"inputStyle\0";
+pub const XCB_XIM_XNFocusWindow: &[u8; 12usize] = b"focusWindow\0";
+pub const XCB_XIM_XNFilterEvents: &[u8; 13usize] = b"filterEvents\0";
+pub const XCB_XIM_XNPreeditAttributes: &[u8; 18usize] = b"preeditAttributes\0";
+pub const XCB_XIM_XNStatusAttributes: &[u8; 17usize] = b"statusAttributes\0";
+pub const XCB_XIM_XNArea: &[u8; 5usize] = b"area\0";
+pub const XCB_XIM_XNAreaNeeded: &[u8; 11usize] = b"areaNeeded\0";
+pub const XCB_XIM_XNSpotLocation: &[u8; 13usize] = b"spotLocation\0";
+pub const XCB_XIM_XNColormap: &[u8; 9usize] = b"colorMap\0";
+pub const XCB_XIM_XNStdColormap: &[u8; 12usize] = b"stdColorMap\0";
+pub const XCB_XIM_XNForeground: &[u8; 11usize] = b"foreground\0";
+pub const XCB_XIM_XNBackground: &[u8; 11usize] = b"background\0";
+pub const XCB_XIM_XNBackgroundPixmap: &[u8; 17usize] = b"backgroundPixmap\0";
+pub const XCB_XIM_XNFontSet: &[u8; 8usize] = b"fontSet\0";
+pub const XCB_XIM_XNLineSpace: &[u8; 10usize] = b"lineSpace\0";
+pub const XCB_XIM_XNSeparatorofNestedList: &[u8; 22usize] = b"separatorofNestedList\0";
+pub const XCB_IM_ALL_LOCALES : & [u8 ; 514usize] = b"aa,af,am,an,ar,as,ast,az,be,bem,ber,bg,bho,bn,bo,br,brx,bs,byn,C,ca,crh,cs,csb,cv,cy,da,de,dv,dz,el,en,es,et,eu,fa,ff,fi,fil,fo,fr,fur,fy,ga,gd,gez,gl,gu,gv,ha,he,hi,hne,hr,hsb,ht,hu,hy,id,ig,ik,is,it,iu,iw,ja,ka,kk,kl,km,kn,ko,kok,ks,ku,kw,ky,lb,lg,li,lij,lo,lt,lv,mag,mai,mg,mhr,mi,mk,ml,mn,mr,ms,mt,my,nan,nb,nds,ne,nl,nn,no,nr,nso,oc,om,or,os,pa,pap,pl,ps,pt,ro,ru,rw,sa,sc,sd,se,shs,si,sid,sk,sl,so,sq,sr,ss,st,sv,sw,ta,te,tg,th,ti,tig,tk,tl,tn,tr,ts,tt,ug,uk,unm,ur,uz,ve,vi,wa,wae,wal,wo,xh,yi,yo,yue,zh,zu\0" ;
 extern "C" {
     pub fn free(__ptr: *mut ::std::os::raw::c_void);
 }
@@ -2303,6 +2300,19 @@ extern "C" {
 extern "C" {
     pub fn xcb_im_ext_move_fr_free(frame: *mut xcb_im_ext_move_fr_t);
 }
+pub const xcb_xim_lookup_flags_t_XCB_XIM_SYNCHRONOUS: xcb_xim_lookup_flags_t = 1;
+pub const xcb_xim_lookup_flags_t_XCB_XIM_LOOKUP_CHARS: xcb_xim_lookup_flags_t = 2;
+pub const xcb_xim_lookup_flags_t_XCB_XIM_LOOKUP_KEYSYM: xcb_xim_lookup_flags_t = 4;
+pub const xcb_xim_lookup_flags_t_XCB_XIM_LOOKUP_BOTH: xcb_xim_lookup_flags_t = 6;
+pub type xcb_xim_lookup_flags_t = ::std::os::raw::c_uint;
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct _xcb_im_ext_list {
+    pub name: *mut ::std::os::raw::c_char,
+    pub major_opcode: u8,
+    pub minor_opcode: u8,
+}
+pub type xcb_im_ext_list = _xcb_im_ext_list;
 pub const _xcb_im_style_t_XCB_IM_PreeditArea: _xcb_im_style_t = 1;
 pub const _xcb_im_style_t_XCB_IM_PreeditCallbacks: _xcb_im_style_t = 2;
 pub const _xcb_im_style_t_XCB_IM_PreeditPosition: _xcb_im_style_t = 4;
@@ -2313,6 +2323,17 @@ pub const _xcb_im_style_t_XCB_IM_StatusCallbacks: _xcb_im_style_t = 512;
 pub const _xcb_im_style_t_XCB_IM_StatusNothing: _xcb_im_style_t = 1024;
 pub const _xcb_im_style_t_XCB_IM_StatusNone: _xcb_im_style_t = 2048;
 pub type _xcb_im_style_t = ::std::os::raw::c_uint;
+pub use self::_xcb_im_style_t as xcb_im_style_t;
+pub const xcb_im_feedback_t_XCB_XIM_REVERSE: xcb_im_feedback_t = 1;
+pub const xcb_im_feedback_t_XCB_XIM_UNDERLINE: xcb_im_feedback_t = 2;
+pub const xcb_im_feedback_t_XCB_XIM_HIGHLIGHT: xcb_im_feedback_t = 4;
+pub const xcb_im_feedback_t_XCB_XIM_PRIMARY: xcb_im_feedback_t = 32;
+pub const xcb_im_feedback_t_XCB_XIM_SECONDARY: xcb_im_feedback_t = 64;
+pub const xcb_im_feedback_t_XCB_XIM_TERTIARY: xcb_im_feedback_t = 128;
+pub const xcb_im_feedback_t_XCB_XIM_VISIBLE_TO_FORWARD: xcb_im_feedback_t = 256;
+pub const xcb_im_feedback_t_XCB_XIM_VISIBLE_TO_BACKWORD: xcb_im_feedback_t = 512;
+pub const xcb_im_feedback_t_XCB_XIM_VISIBLE_TO_CENTER: xcb_im_feedback_t = 1024;
+pub type xcb_im_feedback_t = ::std::os::raw::c_uint;
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct _xcb_im_trigger_keys_t {
@@ -2336,6 +2357,13 @@ pub struct xcb_connection_t {
 }
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
+pub struct xcb_generic_iterator_t {
+    pub data: *mut ::std::os::raw::c_void,
+    pub rem: ::std::os::raw::c_int,
+    pub index: ::std::os::raw::c_int,
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
 pub struct xcb_generic_event_t {
     pub response_type: u8,
     pub pad0: u8,
@@ -2349,6 +2377,9 @@ pub struct xcb_void_cookie_t {
     pub sequence: ::std::os::raw::c_uint,
 }
 pub type xcb_window_t = u32;
+pub type xcb_pixmap_t = u32;
+pub type xcb_cursor_t = u32;
+pub type xcb_gcontext_t = u32;
 pub type xcb_colormap_t = u32;
 pub type xcb_timestamp_t = u32;
 pub type xcb_keysym_t = u32;
@@ -2385,6 +2416,87 @@ pub struct xcb_key_press_event_t {
     pub same_screen: u8,
     pub pad0: u8,
 }
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct xcb_free_pixmap_request_t {
+    pub major_opcode: u8,
+    pub pad0: u8,
+    pub length: u16,
+    pub pixmap: xcb_pixmap_t,
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct xcb_free_gc_request_t {
+    pub major_opcode: u8,
+    pub pad0: u8,
+    pub length: u16,
+    pub gc: xcb_gcontext_t,
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct xcb_free_colormap_request_t {
+    pub major_opcode: u8,
+    pub pad0: u8,
+    pub length: u16,
+    pub cmap: xcb_colormap_t,
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct xcb_copy_colormap_and_free_request_t {
+    pub major_opcode: u8,
+    pub pad0: u8,
+    pub length: u16,
+    pub mid: xcb_colormap_t,
+    pub src_cmap: xcb_colormap_t,
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct xcb_free_colors_request_t {
+    pub major_opcode: u8,
+    pub pad0: u8,
+    pub length: u16,
+    pub cmap: xcb_colormap_t,
+    pub plane_mask: u32,
+}
+#[repr(C)]
+#[derive(Debug, Copy, Clone)]
+pub struct xcb_free_cursor_request_t {
+    pub major_opcode: u8,
+    pub pad0: u8,
+    pub length: u16,
+    pub cursor: xcb_cursor_t,
+}
+extern "C" {
+    pub fn xcb_free_pixmap_checked(
+        c: *mut xcb_connection_t,
+        pixmap: xcb_pixmap_t,
+    ) -> xcb_void_cookie_t;
+}
+extern "C" {
+    pub fn xcb_free_pixmap(c: *mut xcb_connection_t, pixmap: xcb_pixmap_t) -> xcb_void_cookie_t;
+}
+extern "C" {
+    pub fn xcb_free_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
+}
+extern "C" {
+    pub fn xcb_free_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
+}
+extern "C" {
+    pub fn xcb_free_colormap_checked(
+        c: *mut xcb_connection_t,
+        cmap: xcb_colormap_t,
+    ) -> xcb_void_cookie_t;
+}
+extern "C" {
+    pub fn xcb_free_colormap(c: *mut xcb_connection_t, cmap: xcb_colormap_t) -> xcb_void_cookie_t;
+}
+extern "C" {
+    pub fn xcb_copy_colormap_and_free_checked(
+        c: *mut xcb_connection_t,
+        mid: xcb_colormap_t,
+        src_cmap: xcb_colormap_t,
+    ) -> xcb_void_cookie_t;
+}
 extern "C" {
     pub fn xcb_copy_colormap_and_free(
         c: *mut xcb_connection_t,
@@ -2392,6 +2504,52 @@ extern "C" {
         src_cmap: xcb_colormap_t,
     ) -> xcb_void_cookie_t;
 }
+extern "C" {
+    pub fn xcb_free_colors_sizeof(
+        _buffer: *const ::std::os::raw::c_void,
+        pixels_len: u32,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn xcb_free_colors_checked(
+        c: *mut xcb_connection_t,
+        cmap: xcb_colormap_t,
+        plane_mask: u32,
+        pixels_len: u32,
+        pixels: *const u32,
+    ) -> xcb_void_cookie_t;
+}
+extern "C" {
+    pub fn xcb_free_colors(
+        c: *mut xcb_connection_t,
+        cmap: xcb_colormap_t,
+        plane_mask: u32,
+        pixels_len: u32,
+        pixels: *const u32,
+    ) -> xcb_void_cookie_t;
+}
+extern "C" {
+    pub fn xcb_free_colors_pixels(R: *const xcb_free_colors_request_t) -> *mut u32;
+}
+extern "C" {
+    pub fn xcb_free_colors_pixels_length(
+        R: *const xcb_free_colors_request_t,
+    ) -> ::std::os::raw::c_int;
+}
+extern "C" {
+    pub fn xcb_free_colors_pixels_end(
+        R: *const xcb_free_colors_request_t,
+    ) -> xcb_generic_iterator_t;
+}
+extern "C" {
+    pub fn xcb_free_cursor_checked(
+        c: *mut xcb_connection_t,
+        cursor: xcb_cursor_t,
+    ) -> xcb_void_cookie_t;
+}
+extern "C" {
+    pub fn xcb_free_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t) -> xcb_void_cookie_t;
+}
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct _xcb_xim_t {
@@ -2731,6 +2889,16 @@ pub struct _xcb_im_client_t {
     _unused: [u8; 0],
 }
 pub type xcb_im_client_t = _xcb_im_client_t;
+pub const _xcb_im_attr_mask_t_XCB_XIM_XNArea_MASK: _xcb_im_attr_mask_t = 1;
+pub const _xcb_im_attr_mask_t_XCB_XIM_XNAreaNeeded_MASK: _xcb_im_attr_mask_t = 2;
+pub const _xcb_im_attr_mask_t_XCB_XIM_XNSpotLocation_MASK: _xcb_im_attr_mask_t = 4;
+pub const _xcb_im_attr_mask_t_XCB_XIM_XNColormap_MASK: _xcb_im_attr_mask_t = 8;
+pub const _xcb_im_attr_mask_t_XCB_XIM_XNForeground_MASK: _xcb_im_attr_mask_t = 16;
+pub const _xcb_im_attr_mask_t_XCB_XIM_XNBackground_MASK: _xcb_im_attr_mask_t = 32;
+pub const _xcb_im_attr_mask_t_XCB_XIM_XNBackgroundPixmap_MASK: _xcb_im_attr_mask_t = 128;
+pub const _xcb_im_attr_mask_t_XCB_XIM_XNLineSpace_MASK: _xcb_im_attr_mask_t = 256;
+pub type _xcb_im_attr_mask_t = ::std::os::raw::c_uint;
+pub use self::_xcb_im_attr_mask_t as xcb_im_attr_mask_t;
 #[repr(C)]
 #[derive(Debug, Copy, Clone)]
 pub struct _xcb_im_preedit_attr_t {
@@ -2771,6 +2939,21 @@ pub type xcb_im_callback = ::std::option::Option<
 pub type xcb_im_free_function =
     ::std::option::Option<unsafe extern "C" fn(memory: *mut ::std::os::raw::c_void)>;
 extern "C" {
+    #[doc = " Create a XIM server."]
+    #[doc = ""]
+    #[doc = " @param conn xcb connection to be used."]
+    #[doc = " @param screen xcb screen to be used."]
+    #[doc = " @param serverWindow A server window."]
+    #[doc = " @param serverName server name, need to be consistent with XMODIFIERS"]
+    #[doc = " @param locale locale supported. You may want to use XCB_IM_ALL_LOCALES."]
+    #[doc = " @param inputStyles XIM Styles supported by XIM server."]
+    #[doc = " @param onKeysList Trigger on key to send to client."]
+    #[doc = " @param offKeysList Trigger off key to send to cilent."]
+    #[doc = " @param encodingList XIM encoding list."]
+    #[doc = " @param event_mask if 0, XCB_EVENT_MASK_KEY_PRESS will be used."]
+    #[doc = " @param callback Callback function"]
+    #[doc = " @param user_data user data to callback function."]
+    #[doc = " @return xcb_im_t*"]
     pub fn xcb_im_create(
         conn: *mut xcb_connection_t,
         screen: ::std::os::raw::c_int,
@@ -2787,6 +2970,10 @@ extern "C" {
     ) -> *mut xcb_im_t;
 }
 extern "C" {
+    #[doc = " @brief Set a logger handler."]
+    #[doc = ""]
+    #[doc = " @param im XIM server."]
+    #[doc = " @param logger logger function."]
     pub fn xcb_im_set_log_handler(
         im: *mut xcb_im_t,
         logger: ::std::option::Option<
@@ -2795,24 +2982,68 @@ extern "C" {
     );
 }
 extern "C" {
+    #[doc = " Whether to use sync mode, it will affect certain behavior of XIM."]
+    #[doc = ""]
+    #[doc = " Forward event and commit string behavior will be changed. If sync mode is"]
+    #[doc = " true, every request need to be replied with sync_reply. The library is still"]
+    #[doc = " working under async mode, just no more request will be send to client."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param sync sync mode or not."]
     pub fn xcb_im_set_use_sync_mode(im: *mut xcb_im_t, sync: bool);
 }
 extern "C" {
+    #[doc = " Set whether the event defined by event mask is handled in a synchronous way."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param sync sync on event or not."]
     pub fn xcb_im_set_use_sync_event(im: *mut xcb_im_t, sync: bool);
 }
 extern "C" {
+    #[doc = " Start a XIM server synchronously."]
+    #[doc = ""]
+    #[doc = " It only does the minimum initialization and try to grab the server name. When"]
+    #[doc = " it fails, it means there might be another server with the same name running."]
+    #[doc = ""]
+    #[doc = " To finish the initialization, you will need to use xcb_im_filter_event on all"]
+    #[doc = " the event recevied."]
+    #[doc = ""]
+    #[doc = " You may also call this function again if it fails or after xcb_im_close_im."]
+    #[doc = ""]
+    #[doc = " @param im XIM server."]
+    #[doc = " @return whether XIM server is started successfully."]
     pub fn xcb_im_open_im(im: *mut xcb_im_t) -> bool;
 }
 extern "C" {
+    #[doc = " Handle XIM related event, most relevant event will be client message."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param event X event."]
+    #[doc = " @return Whether the event is handled by XIM."]
     pub fn xcb_im_filter_event(im: *mut xcb_im_t, event: *mut xcb_generic_event_t) -> bool;
 }
 extern "C" {
+    #[doc = " Shutdown the XIM server and free all the resources."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = ""]
+    #[doc = " @see xcb_im_open_im"]
     pub fn xcb_im_close_im(im: *mut xcb_im_t);
 }
 extern "C" {
+    #[doc = " Destroy the XIM server."]
+    #[doc = ""]
+    #[doc = " xcb_im_close_im need to be called if it is opened successfully."]
+    #[doc = ""]
+    #[doc = " @param im XIM server."]
     pub fn xcb_im_destroy(im: *mut xcb_im_t);
 }
 extern "C" {
+    #[doc = " Send a key event to the client."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context."]
+    #[doc = " @param event key event."]
     pub fn xcb_im_forward_event(
         im: *mut xcb_im_t,
         ic: *mut xcb_im_input_context_t,
@@ -2820,6 +3051,18 @@ extern "C" {
     );
 }
 extern "C" {
+    #[doc = " Commit a string to the client."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input Context"]
+    #[doc = " @param flag a bit flag of xcb_xim_lookup_flags_t, XCB_XIM_LOOKUP_CHARS is the"]
+    #[doc = " most common value to be used."]
+    #[doc = " @param str string to be committed, encoding is usually COMPOUND_TEXT."]
+    #[doc = " @param length byte length of the string"]
+    #[doc = " @param keysym key symbol."]
+    #[doc = ""]
+    #[doc = " @see xcb_xim_lookup_flags_t"]
+    #[doc = " @see xcb_utf8_to_compound_text"]
     pub fn xcb_im_commit_string(
         im: *mut xcb_im_t,
         ic: *mut xcb_im_input_context_t,
@@ -2830,12 +3073,28 @@ extern "C" {
     );
 }
 extern "C" {
+    #[doc = " Start geometry negotiation, if XIMStyle has XIMPreeditArea or XIMStatusArea"]
+    #[doc = " set."]
+    #[doc = ""]
+    #[doc = " This is rarely used nowadays. Xlib doesn't have relevant code for it."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context"]
     pub fn xcb_im_geometry_callback(im: *mut xcb_im_t, ic: *mut xcb_im_input_context_t);
 }
 extern "C" {
+    #[doc = " Sends XIM_PREEDIT_START message to call the XIMPreeditStartCallback function."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context"]
     pub fn xcb_im_preedit_start_callback(im: *mut xcb_im_t, ic: *mut xcb_im_input_context_t);
 }
 extern "C" {
+    #[doc = " Sends XIM_PREEDIT_DRAW message to call the XIMPreeditDrawCallback function."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context"]
+    #[doc = " @param frame information about preedit string."]
     pub fn xcb_im_preedit_draw_callback(
         im: *mut xcb_im_t,
         ic: *mut xcb_im_input_context_t,
@@ -2843,6 +3102,11 @@ extern "C" {
     );
 }
 extern "C" {
+    #[doc = " Sends XIM_PREEDIT_CARET message to call the PreeditCaretCallback function."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context"]
+    #[doc = " @param frame information about preedit caret."]
     pub fn xcb_im_preedit_caret_callback(
         im: *mut xcb_im_t,
         ic: *mut xcb_im_input_context_t,
@@ -2850,12 +3114,28 @@ extern "C" {
     );
 }
 extern "C" {
+    #[doc = " sends XIM_PREEDIT_DONE message to call the XIMPreeditDoneCallback function."]
+    #[doc = ""]
+    #[doc = " This should only be called after calling xcb_im_preedit_start_callback."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context"]
     pub fn xcb_im_preedit_done_callback(im: *mut xcb_im_t, ic: *mut xcb_im_input_context_t);
 }
 extern "C" {
+    #[doc = " Sends XIM_STATUS_START message to call the XIMStatusStartCallback function."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context"]
     pub fn xcb_im_status_start_callback(im: *mut xcb_im_t, ic: *mut xcb_im_input_context_t);
 }
 extern "C" {
+    #[doc = " Sends XIM_STATUS_DRAW message to call the XIMStatusDrawCallback function with"]
+    #[doc = " text."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context"]
+    #[doc = " @param frame text to be drawn by client."]
     pub fn xcb_im_status_draw_text_callback(
         im: *mut xcb_im_t,
         ic: *mut xcb_im_input_context_t,
@@ -2863,6 +3143,12 @@ extern "C" {
     );
 }
 extern "C" {
+    #[doc = " Sends XIM_STATUS_DRAW message to call the XIMStatusDrawCallback function with"]
+    #[doc = " bitmap."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context"]
+    #[doc = " @param frame bitmap to be drawn by client."]
     pub fn xcb_im_status_draw_bitmap_callback(
         im: *mut xcb_im_t,
         ic: *mut xcb_im_input_context_t,
@@ -2870,6 +3156,10 @@ extern "C" {
     );
 }
 extern "C" {
+    #[doc = " Sends XIM_STATUS_DONE message to call the XIMStatusDoneCallback function."]
+    #[doc = ""]
+    #[doc = " @param im XIM server"]
+    #[doc = " @param ic Input context"]
     pub fn xcb_im_status_done_callback(im: *mut xcb_im_t, ic: *mut xcb_im_input_context_t);
 }
 extern "C" {
diff --git a/src/lib.rs b/src/lib.rs
index 272d1e9..e844f97 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -12,7 +12,7 @@ To get started quickly, consult the examples folder.
 #[macro_use]
 extern crate lazy_static;
 
-use std::os::raw::{c_char, c_void};
+use std::ffi::{c_char, c_void};
 use std::pin::Pin;
 use std::sync::{Arc, Mutex};
 use xcb::x::Window;
@@ -22,7 +22,86 @@ use bitflags::bitflags;
 
 use clib::*;
 
-mod clib;
+pub mod clib;
+
+const XCB_KEY_PRESS: u8 = 2;
+const XCB_KEY_RELEASE: u8 = 3;
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub struct KeyEvent {
+    pub is_press: bool,
+
+    pub detail: u8,
+    pub time: u32,
+    pub root: Window,
+    pub event: Window,
+    pub child: Window,
+    pub root_x: i16,
+    pub root_y: i16,
+    pub event_x: i16,
+    pub event_y: i16,
+    pub state: xcb::x::KeyButMask,
+    pub same_screen: bool,
+}
+
+impl KeyEvent {
+    pub fn to_generic(&self) -> xcb::x::KeyPressEvent {
+        let ptr = xcb::x::KeyPressEvent::new(
+            self.detail,
+            self.time,
+            self.root,
+            self.event,
+            self.child,
+            self.root_x,
+            self.root_y,
+            self.event_x,
+            self.event_y,
+            self.state,
+            self.same_screen,
+        )
+        .into_raw();
+
+        if !self.is_press {
+            unsafe {
+                (*ptr).response_type = XCB_KEY_RELEASE;
+            }
+        }
+
+        unsafe { xcb::x::KeyPressEvent::from_raw(ptr) }
+    }
+
+    fn from_raw(ev: &xcb_key_press_event_t) -> Self {
+        Self {
+            is_press: (ev.response_type & 0x7F) == XCB_KEY_PRESS,
+
+            detail: ev.detail,
+            time: ev.time,
+            root: unsafe { Window::new(ev.root) },
+            event: unsafe { Window::new(ev.event) },
+            child: unsafe { Window::new(ev.child) },
+            root_x: ev.root_x,
+            root_y: ev.root_y,
+            event_x: ev.event_x,
+            event_y: ev.event_y,
+            state: xcb::x::KeyButMask::from_bits(ev.state as u32).unwrap(),
+            same_screen: ev.same_screen != 0,
+        }
+    }
+
+    pub fn from_xevent(xev: xcb::x::Event) -> Option<Self> {
+        match xev {
+            xcb::x::Event::KeyPress(ev) => {
+                let ev = unsafe { &*(ev.as_raw() as *const xcb_key_press_event_t) };
+                Some(Self::from_raw(ev))
+            }
+            xcb::x::Event::KeyRelease(ev) => {
+                let ev = unsafe { &*(ev.as_raw() as *const xcb_key_press_event_t) };
+                Some(Self::from_raw(ev))
+            }
+            _ => None,
+        }
+    }
+}
 
 type LogFn = dyn for<'a> FnMut(&'a str) + Send;
 
@@ -137,35 +216,25 @@ extern "C" fn update_pos_callback(_im: *mut xcb_xim_t, ic: xcb_xic_t, user_data:
     }
 }
 
-const XCB_KEY_PRESS: u8 = 2;
-const XCB_KEY_RELEASE: u8 = 3;
-
 extern "C" fn forward_event_callback(
     _im: *mut xcb_xim_t,
     _ic: xcb_xic_t,
     event: *mut xcb_key_press_event_t,
     user_data: *mut c_void,
 ) {
-    let pressed = unsafe { ((*event).response_type & 0x7f) == XCB_KEY_PRESS };
-    let ptr = event as *const xcb::ffi::xcb_generic_event_t;
-    let event = unsafe {
-        if pressed {
-            xcb::Event::X(xcb::x::Event::KeyPress(xcb::x::KeyPressEvent::from_raw(
-                ptr as _,
-            )))
-        } else {
-            xcb::Event::X(xcb::x::Event::KeyRelease(
-                xcb::x::KeyReleaseEvent::from_raw(ptr as _),
-            ))
-        }
-    };
+    let response_type = unsafe { (*event).response_type } & 0x7F;
+    if !(response_type == XCB_KEY_PRESS || response_type == XCB_KEY_RELEASE) {
+        return;
+    }
+
+    let key_event = KeyEvent::from_raw(unsafe { &*event });
+
     let ime = unsafe { ime_from_user_data(user_data) };
     let win = unsafe { Window::new(ime.pos_req.win) };
-    ime.callbacks.forward_event.as_mut().map(|f| f(win, &event));
-
-    // xcb::KeyPressEvent has a Drop impl that will free `event`, but since we don't own it, we
-    // have to prevent that from happening
-    std::mem::forget(event);
+    ime.callbacks
+        .forward_event
+        .as_mut()
+        .map(|f| f(win, key_event));
 }
 
 extern "C" fn preedit_start_callback(_im: *mut xcb_xim_t, _ic: xcb_xic_t, user_data: *mut c_void) {
@@ -212,7 +281,7 @@ bitflags! {
 }
 
 type StringCB = dyn for<'a> FnMut(Window, &'a str);
-type KeyPressCB = dyn for<'a> FnMut(Window, &'a xcb::Event);
+type KeyPressCB = dyn FnMut(Window, KeyEvent);
 type PreeditDrawCB = dyn for<'a> FnMut(Window, PreeditInfo<'a>);
 type NotifyCB = dyn FnMut(Window);
 
@@ -552,7 +621,7 @@ impl ImeClient {
     /// [`update_pos`]: ImeClient::update_pos
     pub fn set_forward_event_cb<F>(&mut self, f: F)
     where
-        F: for<'a> FnMut(Window, &'a xcb::Event) + 'static,
+        F: FnMut(Window, KeyEvent) + 'static,
     {
         self.callbacks.forward_event = Some(Box::new(f));
     }
@@ -609,3 +678,240 @@ impl Drop for ImeClient {
         }
     }
 }
+
+#[derive(Clone, PartialEq, Eq)]
+pub struct Ic(*mut clib::xcb_im_input_context_t);
+unsafe impl Send for Ic {}
+
+use std::cell::RefCell;
+
+struct UserData {
+    im_server: *const ImeServer,
+    callbacks: RefCell<ImeServerCallbacks>,
+    position_cache: RefCell<(Ic, i16, i16)>,
+}
+
+pub struct ImeServer {
+    _conn: Arc<xcb::Connection>,
+    im: *mut xcb_im_t,
+    user_data: *mut UserData,
+}
+
+impl ImeServer {
+    pub fn new(
+        conn: Arc<xcb::Connection>,
+        screen_id: i32,
+        server_window: Window,
+        im_name: &str,
+        forward_key_release: bool,
+        callbacks: ImeServerCallbacks,
+    ) -> Pin<Box<Self>> {
+        unsafe { xcb_compound_text_init() };
+
+        let mut styles = [
+            _xcb_im_style_t_XCB_IM_PreeditPosition | _xcb_im_style_t_XCB_IM_StatusArea, // OverTheSpot
+            _xcb_im_style_t_XCB_IM_PreeditPosition | _xcb_im_style_t_XCB_IM_StatusNothing, // OverTheSpot
+            _xcb_im_style_t_XCB_IM_PreeditPosition | _xcb_im_style_t_XCB_IM_StatusNone, // OverTheSpot
+        ];
+        let styles = xcb_im_styles_t {
+            nStyles: styles.len() as u32,
+            styles: styles.as_mut_ptr() as _,
+        };
+
+        let mut compound_text: [u8; 14] = *b"COMPOUND_TEXT\0";
+        let mut encodings = [compound_text.as_mut_ptr() as *mut c_char];
+        let encodings = xcb_im_encodings_t {
+            nEncodings: encodings.len() as u16,
+            encodings: encodings.as_mut_ptr(),
+        };
+
+        let im_name = std::ffi::CString::new(im_name).unwrap();
+
+        let event_mask = if forward_key_release {
+            xcb::x::EventMask::KEY_PRESS | xcb::x::EventMask::KEY_RELEASE
+        } else {
+            xcb::x::EventMask::KEY_PRESS
+        };
+
+        let user_data = Box::into_raw(Box::new(UserData {
+            im_server: std::ptr::null(),
+            callbacks: RefCell::new(callbacks),
+            position_cache: RefCell::new((Ic(std::ptr::null_mut()), 0, 0)),
+        }));
+
+        let im: *mut xcb_im_t = unsafe {
+            xcb_im_create(
+                conn.get_raw_conn() as _,
+                screen_id,
+                server_window.resource_id(),
+                im_name.as_ptr() as *const c_char,
+                XCB_IM_ALL_LOCALES.as_ptr() as *const c_char,
+                &styles,
+                std::ptr::null_mut(), // on keys
+                std::ptr::null_mut(), // off keys
+                &encodings,
+                event_mask.bits(),
+                Some(im_server_callback),
+                user_data as *mut c_void,
+            )
+        };
+        assert!(unsafe { xcb_im_open_im(im) }, "failed to start IM server");
+
+        let im_server = unsafe {
+            let im_server_ptr = Box::into_raw(Box::new(Self {
+                _conn: conn,
+                im,
+                user_data,
+            }));
+            (*user_data).im_server = im_server_ptr;
+            Box::from_raw(im_server_ptr)
+        };
+
+        Box::into_pin(im_server)
+    }
+
+    pub fn process_event(&self, event: xcb::Event) {
+        let event = &event;
+        unsafe { xcb_im_filter_event(self.im, event.as_raw() as _) };
+    }
+
+    pub fn forward_event(&self, ic: Ic, key_event: KeyEvent) {
+        let key_press = key_event.to_generic();
+        unsafe { xcb_im_forward_event(self.im, ic.0, key_press.as_raw() as _) };
+    }
+
+    pub fn commit_string(&self, ic: Ic, text: &str) {
+        unsafe {
+            let mut len: usize = 0;
+            let result = xcb_utf8_to_compound_text(
+                text.as_ptr() as *const c_char,
+                text.len(),
+                &mut len as *mut usize,
+            );
+            xcb_im_commit_string(
+                self.im,
+                ic.0,
+                xcb_xim_lookup_flags_t_XCB_XIM_LOOKUP_CHARS,
+                result,
+                len as u32,
+                0,
+            );
+            free(result as _);
+        }
+    }
+
+    pub fn get_client_window(&self, ic: &Ic) -> Window {
+        let win = unsafe { clib::xcb_im_input_context_get_client_window(ic.0) };
+        unsafe { Window::new(win) }
+    }
+}
+
+impl Drop for ImeServer {
+    fn drop(&mut self) {
+        unsafe { xcb_im_close_im(self.im) };
+        unsafe { xcb_im_destroy(self.im) };
+
+        assert!(!self.user_data.is_null());
+        drop(unsafe { Box::from_raw(self.user_data) });
+        self.user_data = std::ptr::null_mut();
+    }
+}
+
+pub type ImeServerTriggerCB = dyn for<'a> FnMut(&'a ImeServer, Ic, bool);
+pub type ImeServerIcFocusInCB = dyn for<'a> FnMut(&'a ImeServer, Ic);
+pub type ImeServerIcFocusOutCB = dyn for<'a> FnMut(&'a ImeServer, Ic);
+pub type ImeServerForwardCB = dyn for<'a> FnMut(&'a ImeServer, Ic, KeyEvent);
+pub type ImeServerPositionChangedCB = dyn for<'a> FnMut(&'a ImeServer, Ic, Window, i16, i16);
+
+pub struct ImeServerCallbacks {
+    pub trigger: Box<ImeServerTriggerCB>,
+    pub focus_in: Box<ImeServerIcFocusInCB>,
+    pub focus_out: Box<ImeServerIcFocusOutCB>,
+    pub forward: Box<ImeServerForwardCB>,
+    pub position_changed: Box<ImeServerPositionChangedCB>,
+}
+
+#[no_mangle]
+extern "C" fn im_server_callback(
+    _im: *mut xcb_im_t,
+    _client: *mut xcb_im_client_t,
+    ic: *mut xcb_im_input_context_t,
+    hdr: *const xcb_im_packet_header_fr_t,
+    frame: *mut c_void,
+    arg: *mut c_void,
+    user_data: *mut c_void,
+) {
+    let user_data: &UserData = unsafe { &*(user_data as *const UserData) };
+    let im_server = unsafe { &*user_data.im_server };
+    let callbacks = &user_data.callbacks;
+    let position_cache = &user_data.position_cache;
+
+    let opcode_major: u32 = unsafe { (*hdr).major_opcode } as u32;
+
+    match opcode_major {
+        XCB_XIM_OPEN => {}
+        XCB_XIM_CLOSE => {}
+
+        XCB_XIM_SET_IC_FOCUS => {
+            (callbacks.borrow_mut().focus_in)(im_server, Ic(ic));
+        }
+        XCB_XIM_UNSET_IC_FOCUS => {
+            (callbacks.borrow_mut().focus_out)(im_server, Ic(ic));
+        }
+
+        XCB_XIM_TRIGGER_NOTIFY => {
+            let frame: *mut xcb_im_trigger_notify_fr_t = frame as _;
+            if unsafe { (*frame).flag } == 0 {
+                (callbacks.borrow_mut().trigger)(im_server, Ic(ic), true);
+            } else if unsafe { (*frame).flag } == 1 {
+                (callbacks.borrow_mut().trigger)(im_server, Ic(ic), false);
+            }
+        }
+
+        XCB_XIM_FORWARD_EVENT => {
+            let generic_event: *const xcb_generic_event_t = arg as _;
+            let event_type = unsafe { (*generic_event).response_type };
+            if !(event_type == XCB_KEY_PRESS || event_type == XCB_KEY_RELEASE) {
+                return;
+            }
+
+            let key_event: *const xcb_key_press_event_t = generic_event as _;
+            let event = unsafe { &*key_event };
+
+            let key_event = KeyEvent {
+                is_press: event.response_type == XCB_KEY_PRESS,
+
+                detail: event.detail,
+                time: event.time,
+                root: unsafe { Window::new(event.root) },
+                event: unsafe { Window::new(event.event) },
+                child: unsafe { Window::new(event.child) },
+                root_x: event.root_x,
+                root_y: event.root_y,
+                event_x: event.event_x,
+                event_y: event.event_y,
+                state: xcb::x::KeyButMask::from_bits(event.state as u32).unwrap(),
+                same_screen: event.same_screen != 0,
+            };
+
+            (callbacks.borrow_mut().forward)(im_server, Ic(ic), key_event);
+        }
+
+        _ => {}
+    }
+
+    if !ic.is_null() {
+        let wid = unsafe { xcb_im_input_context_get_client_window(ic) };
+        let win = unsafe { Window::new(wid) };
+
+        let preedit_attr = unsafe { &*xcb_im_input_context_get_preedit_attr(ic) };
+        let pos_x = preedit_attr.spot_location.x;
+        let pos_y = preedit_attr.spot_location.y;
+
+        let ic = Ic(ic);
+        if *position_cache.borrow() != (ic.clone(), pos_x, pos_y) {
+            *position_cache.borrow_mut() = (ic.clone(), pos_x, pos_y);
+            (callbacks.borrow_mut().position_changed)(im_server, ic, win, pos_x, pos_y);
+        }
+    }
+}
diff --git a/xcb-imdkit.h b/xcb-imdkit.h
index 925e569..d3733de 100644
--- a/xcb-imdkit.h
+++ b/xcb-imdkit.h
@@ -1,7 +1,7 @@
-#include <xcb-imdkit/encoding.h>
-#include <xcb-imdkit/imclient.h>
-#include <xcb-imdkit/imdkit.h>
-#include <xcb-imdkit/xcbimdkit_export.h>
-#include <xcb-imdkit/ximcommon.h>
-#include <xcb-imdkit/ximproto-gen.h>
-#include <xcb-imdkit/ximproto.h>
+#include "encoding.h"
+#include "imclient.h"
+#include "imdkit.h"
+#include "xcbimdkit_export.h"
+#include "ximcommon.h"
+#include "ximproto-gen.h"
+#include "ximproto.h"
